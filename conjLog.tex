\section{ConjLog}

\subsection{Interfaz}

\sexc{Conj($\alpha$)}
\generos{conjLog($\alpha$)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection*{Operaciones}

\operacion{nuevo}{}{res:conjLog($\alpha$)}
{true}
{$res \igobs \emptyset$}
{Crea un nuevo conjLog vacio}
{O(1)}
{}

\operacion{está}{in cl:conjLog($\alpha$),in e:$\alpha$}{res : bool}
{true}
{$res = (e \in cl)$}
{Retorna un booleano que indica si el elemento pertenece al conjunto}
{$O(log(\#(cl)))$}
{}

\operacion{insertar}{in/out cl:cl($\alpha$), in e:$\alpha$}{}
{$cl_0 \igobs cl \land \neg(e \in cl)$}
{$cl_0 \igobs Agregar(cl_0, e)$}
{Inserta un nuevo elemento en el conjunto}
{O($log(\#(cl))$)}
{}

\operacion{borrar}{in/out cl:cl($\alpha$), in e:$\alpha$}{}
{$cl_0 \igobs cl \land (e \in cl)$}
{$cl \igobs (cl_0 - \{e\})$}
{Elimina el elemento e del conjunto cl, los iteradores que apunten a este elemento se indefinen}
{O($log(\#(cl))$)}
{}

\subsection{Representación}

\serc{clog}{
	\\
	\donde{clog}{ raiz : \mbox{puntero(nodo)}
	}	
	\donde{nodo}{\tupla{
		der : \mbox{puntero(nodo)},
		izq : \mbox{puntero(nodo)},
		valor : \mbox{$\alpha$},
		padre : \mbox{puntero(nodo)},
		fdb : \mbox{nat}
	}}
}

\newpage
\subsection{Invariante de representación}

\begin{enumerate}
	\item Para todas las raíces, la altura del subárbol derecho menos la altura del subárbol izquierdo de esa raíz es igual al fdb.
	\item El fdb de todas las raíces es 0, 1 o -1.
	\item Si un nodo no es una hoja del árbol entonces los padres de los hijos derecho e izquierdo son iguales y es el nodo
	\item Si un nodo es una hoja del arbol entonces los hijos derecho e izquierdo del árbol son NULL
	\item Para todos los nodos n, todos los nodos del subárbol derecho son mayores que n
	\item Para todos los nodos n, todos los nodos del subárbol izquierdo son menores que n
	\item No hay nodos repetidos
	\item El padre de la raíz es NULL
\end{enumerate}

\subsection{Función de abstracción}

\abs{clog($\alpha$)}{conj($\alpha$)}{cl}{c} \\
$((\paratodo{\alpha}{e}) e \in c \impluego esta(cl,e)) \land size(cl) = \#(c)$

\newpage
\subsection{Algoritmos}

\algoritmo{iBorrar}{in/out cl:conjLog($\alpha$), in e : $\alpha$}{}{
	\State $clactual \larr cl$ \complejidad{O(1)}
	\State \If {$(\neg(cl.der==NULL) \land \neg(cl.izq=NULL))$} \complejidad{O(1)}
		\State $clactual \larr {\Fun{iEncontrarPadre}(clactual, e)}$ \complejidad{O($log(size(cl))$)}
		\State \If {$(clactual.der.valor == e)$} \complejidad{O(1)}
			\State $ mm \larr {\Fun{iDameMayMenores}(clactual.der.izq)}$ \complejidad{O($log(size(cl))$)}
			\State $ padremm \larr mm.padre$ \complejidad{O(1)}
			\State 
			\If {$padremm.valor == e$} 
				\State $padremm.fdb++$ \complejidad{O(1)}
				\State $mm.fdb \larr clactual.der.fdb$ \complejidad{O(1)}
				\State $mm.der \larr clactual.der.der$ \complejidad{O(1)}
				\State $mm.padre \larr clactual$ \complejidad{O(1)}
				\State $mm.padre.der \larr mm$ \complejidad{O(1)}
				\State $mm.der.padre \larr mm$ \complejidad{O(1), Si no son NULL}
				\State $mm.izq.padre \larr mm$ \complejidad{O(1), Si no son NULL}
				\State ${\Fun{iRebYRecalcFDB}(padremm,false,true)}$ \complejidad{O($log(size(cl))$)}
			\Else
				\State $padremm.fdb--$ \complejidad{O(1)}
				\State $mm.fdb \larr clactual.der.fdb$ \complejidad{O(1)}
				\State $mm.der \larr clactual.der.der$ \complejidad{O(1)}
				\State $mm.izq \larr clactual.der.izq$ \complejidad{O(1)}
				\State $mm.padre \larr clactual$ \complejidad{O(1)}
				\State $mm.padre.der \larr mm$ \complejidad{O(1)}
				\State $mm.der.padre \larr mm$ \complejidad{O(1), Si no son NULL}
				\State $mm.izq.padre \larr mm$ \complejidad{O(1), Si no son NULL}
				\State ${\Fun{iRebYRecalcFDB}(padremm,true,true)}$ \complejidad{O($log(size(cl))$)}
			\EndIf
		\Else
			\State $ mm \larr {\Fun{iDameMayMenores}(clactual.izq.izq)}$ \complejidad{O($log(size(cl.izq.izq))$)}
			\State $ padremm \larr mm.padre$ \complejidad{O(1)}
			\State 
			\If {$padremm.valor == e$} 
				\State $padremm.fdb++$ \complejidad{O(1)}
				\State $mm.fdb \larr clactual.izq.fdb$ \complejidad{O(1)}
				\State $mm.der \larr clactual.izq.der$ \complejidad{O(1)}
				\State $mm.padre \larr clactual$ \complejidad{O(1)}
				\State $mm.padre.izq \larr mm$ \complejidad{O(1)}
				\State $mm.der.padre \larr mm$ \complejidad{O(1), Si no son NULL}
				\State $mm.izq.padre \larr mm$ \complejidad{O(1), Si no son NULL}
				\State ${\Fun{rebYRecalcFDB}(padremm,false,true)}$ \complejidad{O($log(size(cl))$)}
			\Else
				\State $padremm.fdb--$ \complejidad{O(1)}
				\State $mm.fdb \larr clactual.der.fdb$ \complejidad{O(1)}
				\State $mm.der \larr clactual.der.der$ \complejidad{O(1)}
				\State $mm.izq \larr clactual.der.izq$ \complejidad{O(1)}
				\State $mm.padre \larr clactual$ \complejidad{O(1)}
				\State $mm.padre.der \larr mm$ \complejidad{O(1)}
				\State $mm.der.padre \larr mm$ \complejidad{O(1), Si no son NULL}
				\State $mm.izq.padre \larr mm$ \complejidad{O(1), Si no son NULL}
				\State ${\Fun{iRebYRecalcFDB}(padremm,true,true)}$ \complejidad{O($log(size(cl))$)}
			\EndIf
		\EndIf
	\Else
		\State \If {$cl.der==NULL \land cl.izq==NULL$} \complejidad{O(1)}
			\State $res \larr NULL$ \complejidad{O(1)}
		\Else
			\State \If {$cl.der==NULL$} \complejidad{O(1)}
				\State \If {$cl.izq.valor==e$} \complejidad{O(1)}
					\State $cl.izq \larr NULL$ \complejidad{O(1)}
				\Else
					\State $cl.valor \larr cl.izq.valor$ \complejidad{O(1)}
					\State $cl.izq \larr NULL$ \complejidad{O(1)}
				\EndIf
			\Else
				\State \If {$cl.der.valor==e$} \complejidad{O(1)}
					\State $cl.der \larr NULL$ \complejidad{O(1)}
				\Else
					\State $cl.valor \larr cl.der.valor$ \complejidad{O(1)}
					\State $cl.der \larr NULL$ \complejidad{O(1)}
				\EndIf
			\EndIf
		\EndIf
	\EndIf
}
{O($log(size(cl))$)}

\algoritmo{iInsertar}{in/out cl:conjLog($\alpha$), in e : $\alpha$}{}{
	\State \If {$\neg(cl.der==NULL) \land \neg(cl.izq==NULL)$} \complejidad{O(1)}
		\State $clactual \larr {\Fun{iEncontrarPadre}(clactual, e)}$ \complejidad{O($log(size(cl))$)}
		\State \If {$clactual.valor < e$}
			\State $clactual.der \larr $\tupla{der:NULL, izq:NULL, valor:e, padre:clactual, fdb:0} \complejidad{O(1)}
			\State ${\Fun{iRebYRecalcFDB}(clactual,true,false)}$
		\Else
			\State $clactual.izq \larr $\tupla{der:NULL, izq:NULL, valor:e, padre:clactual, fdb:0} \complejidad{O(1)}
			\State ${\Fun{iRebYRecalcFDB}(clactual,false,false)}$
		\EndIf
	\Else
		\State \If {$cl.der==NULL \land cl.izq==NULL$} \complejidad{O(1)}
			\State $cl \larr $\tupla{der:NULL, izq:NULL, valor:e, padre:clactual, fdb:0} \complejidad{O(1)}
		\Else
			\State \If {$cl.der!=NULL$}
				\State $cl.izq \larr $\tupla{der:NULL,izq:NULL,valor:e,padre:cl,fdb:0} \complejidad{O(1)}
			\Else
				\State $cl.der \larr $\tupla{der:NULL,izq:NULL,valor:e,padre:cl,fdb:0} \complejidad{O(1)}
			\EndIf
		\EndIf
	\EndIf
}
{O($log(size(cl))$)}

\algoritmo{iEstá}{in/out cl:conjLog($\alpha$), in e:$\alpha$}{res:bool}{
	\State $encontrado? \larr false$ \complejidad{O(1)}
	\State $clactual \larr cl$ \complejidad{O(1)}
	\State \While{$(clactual != NULL) \land \neg(encontrado?)$} \complejidad{O(1)}
		\State \If {$e > clactual.valor$} \complejidad{O(1)}
			\State $clactual \larr clactual.der$ \complejidad{O(1)}
		\Else
			\State \If {$ce < clactual.valor$} \complejidad{O(1)}
				\State $clactual \larr clactual.izq$ \complejidad{O(1)}
			\Else
				\State $encontrado? \larr true$ \complejidad{O(1)}
			\EndIf
		\EndIf
	\EndWhile
	\State $clactual \larr NULL$ \complejidad{O(1)}
	\State $res \larr encontrado?$ \complejidad{O(1)}
}
{}

\newpage
\subsection{Auxiliares}
\algoritmo{iRebYRecalcFDB}{in/out cl:conjLog($\alpha$), in borroInsertoHijoDerecho?:bool, in estoyBorrando?:bool}{}{
	\State \While{$cl != NULL \yluego cl.fdb != 2 \land cl.fdb != -2$} \complejidad{O(1)}
		\State \If{$estoyBorrando?$} \complejidad{O(1)}
			\State \If{$borroInsertoHijoDerecho?$} \complejidad{O(1)}
				\State $cl.fdb--$ \complejidad{O(1)}
			\Else
				\State $cl.fdb++$ \complejidad{O(1)}
			\EndIf
			\State $borroInsertoHijoDerecho? \larr (cl.padre.der != NULL \yluego cl.padre.der.valor==cl.valor)$ \complejidad{O(1)}
			\State $cl \larr cl.padre$ \complejidad{O(1)}
		\Else
			\State \If{$borroInsertoHijoDerecho?$} \complejidad{O(1)}
				\State $cl.fdb++$ \complejidad{O(1)}
			\Else
				\State $cl.fdb--$ \complejidad{O(1)}
			\EndIf
			\State $borroInsertoHijoDerecho? \larr (cl.padre.izq != NULL \yluego cl.padre.izq.valor==cl.valor)$ \complejidad{O(1)}
			\State $cl \larr cl.padre$ \complejidad{O(1)}
		\EndIf
	\EndWhile
	\State \If{$cl != NULL$} \complejidad{O(1)}
		\State ${\Fun{iRotar}(cl)}$ \complejidad{O(1)}
	\EndIf
}
{O($log(size(cl))$)}

\newpage
\algoritmo{iRotar}{in/out cl:conjLog($\alpha$)}{}{
	\State \If {$cl.fdb == +2$} \complejidad{O(1)}
		\State \If {$cl.der.fdb == +1$} \complejidad{O(1)}
			\State $\var{q} \larr cl.der$
			\State $\var{izqp} \larr cl.izq$
			\State $cl.der \larr q.der$
			\State $q.der.padre \larr cl$
			\State $cl.izq \larr $\tupla{der: NULL, izq:NULL, valor: cl.valor, padre: cl.izq, fdb:0}
			\State $cl.izq.der \larr q.izq$
			\State $cl.izq.izq \larr izqp$
			\State $cl.izq.der.padre = cl.izq$
			\State $cl.izq.izq.padre = cl.izq$
			\State $cl.valor \larr q.valor$
			\State $cl.fdb \larr 0$
			\State $cl.der.fdb \larr 0$
		\Else
			\State \If {$cl.der.fdb == 0$} \complejidad{O(1)}
				\State $\var{q} \larr cl.der$
				\State $\var{izqp} \larr cl.izq$
				\State $cl.der \larr q.der$
				\State $q.der.padre \larr cl$
				\State $cl.izq \larr $\tupla{der: NULL, izq:NULL, valor: cl.valor, padre: cl.izq, fdb:0}
				\State $cl.izq.der \larr q.izq$
				\State $cl.izq.izq \larr izqp$
				\State $cl.izq.der.padre = cl.izq$
				\State $cl.izq.izq.padre = cl.izq$
				\State $cl.valor \larr q.valor$
				\State $cl.fdb \larr -1$
				\State $cl.izq.fdb \larr +1$
			\Else
				\State \If {$cl.der.fdb==-1$} \complejidad{O(1)}
					\State $\var{r} \larr cl.der.izq$ \complejidad {O(1)}
					\State $cl.der.izq \larr r.der$
					\State $cl.der.izq.padre \larr cl.der$
					\State $\var{clizq} \larr cl.izq$ \complejidad{O(1)}
					\State $cl.izq \larr $\tupla{der:NULL,izq:NULL,valor:cl.valor,padre:cl,fdb:0} \complejidad{O(1)}
					\State $cl.izq.der \larr r.izq$ \complejidad{O(1)}
					\State $cl.izq.izq \larr clizq$ \complejidad{O(1)}
					\State $cl.izq.izq.padre \larr cl.izq$ \complejidad{O(1)}
					\State $cl.izq.der.padre \larr cl.izq$ \complejidad{O(1)}
					\State $cl.valor \larr r.valor$ \complejidad{O(1)}
					\State \If {$r.fdb == -1$} \complejidad {O(1)}
						\State $cl.fdb \larr 0$ \complejidad{O(1)}
						\State $cl.izq.fdb \larr 0$ \complejidad{O(1)}
						\State $cl.der.fdb \larr +1$ \complejidad{O(1)}
					\Else
						\State $cl.fdb \larr 0$ \complejidad{O(1)}
						\State $cl.der.fdb \larr 0$ \complejidad{O(1)}
						\State $cl.izq.fdb \larr -1$ \complejidad{O(1)}
					\EndIf
					\State $r \larr NULL$ \complejidad{O(1)}
				\EndIf
			\EndIf
		\EndIf
		\Else
		\State \If {$cl.izq.fdb == +1$} \complejidad{O(1)}
			\State $\var{q} \larr cl.izq$
			\State $\var{derp} \larr cl.der$
			\State $cl.izq \larr q.der$
			\State $q.der.padre \larr cl$
			\State $cl.der \larr $\tupla{der: NULL, izq:NULL, valor: cl.valor, padre: derp, fdb:0}
			\State $cl.der.der \larr derp.der$
			\State $cl.der.izq \larr q.izq$
			\State $cl.der.der.padre = cl.der$
			\State $cl.der.izq.padre = cl.der$
			\State $cl.valor \larr q.valor$
			\State $cl.fdb \larr 0$
			\State $cl.der.fdb \larr 0$
			\State $derp \larr NULL$
		\Else
			\State $\var{q} \larr cl.izq$
			\State \If {$\var{q}.fdb == 0$} \complejidad{O(1)}
				\State $\var{derp} \larr cl.der$
				\State $cl.izq \larr q.der$
				\State $q.izq.padre \larr cl$
				\State $cl.der \larr $\tupla{der: NULL, izq:NULL, valor: cl.valor, padre: derp, fdb:0}
				\State $cl.der.der \larr derp$
				\State $cl.der.izq \larr q.izq$
				\State $cl.der.der.padre = cl.der$
				\State $cl.der.izq.padre = cl.der$
				\State $cl.valor \larr q.valor$
				\State $cl.fdb \larr +1$
				\State $cl.der.fdb \larr -1$
			\Else
				\State \If {$q.fdb==-1$} \complejidad{O(1)}
					\State $\var{r} \larr q.izq$ \complejidad {O(1)}
					\State $q.izq \larr r.der$
					\State $q.izq.padre \larr q$
					\State $\var{derp} \larr cl.der$ \complejidad{O(1)}
					\State $cl.der \larr $\tupla{der:NULL,izq:NULL,valor:cl.valor,padre:cl,fdb:0} \complejidad{O(1)}
					\State $cl.der.der \larr r.izq$ \complejidad{O(1)}
					\State $cl.der.izq \larr derp$ \complejidad{O(1)}
					\State $cl.der.izq.padre \larr cl.der$ \complejidad{O(1)}
					\State $cl.der.der.padre \larr cl.der$ \complejidad{O(1)}
					\State $cl.valor \larr r.valor$ \complejidad{O(1)}
					\State \If {$r.fdb == -1$} \complejidad {O(1)}
						\State $cl.fdb \larr 0$ \complejidad{O(1)}
						\State $cl.der.fdb \larr 0$ \complejidad{O(1)}
						\State $cl.izq.fdb \larr +1$ \complejidad{O(1)}
					\Else
						\State $cl.fdb \larr 0$ \complejidad{O(1)}
						\State $cl.izq.fdb \larr 0$ \complejidad{O(1)}
						\State $cl.der.fdb \larr -1$ \complejidad{O(1)}
					\EndIf
					\State $r \larr NULL$ \complejidad{O(1)}
				\EndIf
			\EndIf
		\EndIf
	\EndIf
}
{O(1)}
