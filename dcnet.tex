%\\\\\\\\\\\\!TEX root = tp2.tex

\section{DCNet}

Una DCNet es

\subsection{Interfaz}

\sexc{DCNet}
$\textbf{usa}$  
Compu, Paquete, Red, diccPref, conjLog, conjLogP
\generos{dcnet}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection*{Operaciones}


\operacion{crearSistema}{in r: red}{res : dcnet}
 {true}
 {$\var{res} \igobs iniciarDCNet(r)$}
 {Crea un sistema DCNet.}
 {O(?????????????????????????????????????)}

\operacion{crearPaquete}{in/out s: dcnet,in p: paquete}{}
 {$s \igobs s_0 \land FALTA CHOCLO$}
 {$s \igobs crearPaquete(s_0, p)$}
 {Crea un paquete y lo agrega a la computadora correspondiente.}
 {O($L + log(k)$)}

\operacion{avanzarSegundo}{in/out s: dcnet}{}
 {$s \igobs s_0$}
 {$s \igobs avanzarSegundo(s_0)$}
 {Avanza un segundo el sistema. Todas las computadoras envían su respectivo paquete y en consecuencia se actualizar los paquetes en espera de cada una de ellas.}
 {O($n \times\ (L + log(n) + log(k))$)}

\operacion{dameRed}{in s: dcnet}{res : red}
 {$true$}
 {$\var{res} \igobs red(s)$}
 {Devuelve la red de DCNet.}
 {O($????????????????????????????????????$)}

\operacion{caminoRecorrido}{in s: dcnet,in p: paquete}{res : secu(compu)}
 {$paqueteEnTransito?(s,p)$}
 {$\var{res} \igobs caminoRecorrido(s,p)$}
 {Devuelve el camino recorrido hasta el momento por un paquete.}
 {O($n \times\  log(max(n,k))$)}

\operacion{cantidadEnviados}{in s: dcnet,in c: compu}{res : nat}
 {$c \in computadoras(red(s))$}
 {$\var{res} \igobs cantidadEnviados(s,c)$}
 {Devuelve la cantidad de paquetes enviados por una computadora.}
 {O($n$)} %es recorrer todas lascompus del vector e ir al heap que tiene guardado cuantos paquetes envio cada una no ?

\operacion{enEspera}{in s: dcnet,in c: compu}{res: puntero(conjLogP(paquete)))}
 {$c \in computadoras(red(s))$}
 {$\var{res} \igobs enEspera(s,c)$}
 {Devuelve un iterador a los paquetes de la computadora.}
 {O(L)}

\operacion{laQueMasEnvio}{in s: dcnet}{res : compu}
 {$true$}
 {$\var{res} \igobs laQueMasEnvio(s,p)$}
 {Devuelve la computadora que más paquetes envió.}
 {O(1)}

Las complejidades están en función de las siguientes variables:\\
$n$ : la cantidad total de computadoras que hay en el sistema, \\
$L$ : el hostname más largo de todas las computadoras, \\
$k$ : la cola de paquetes más larga de todas las computadoras. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Representación}

\serc{sistema}{
	\\
	\donde{sistema}{\tupla{
			Compus : \mbox{arreglo(\tupla{IP: String , pN: puntero(conjLog(paquete)), \#Paquetes: nat, Num: nat})}, %esto quedo feo
			CompusPorPref : \mbox{diccPref(compu,\tupla{PorNom: conjLog(paquete), PorPrior: conjLog(paquete)}},
      CaminosMinimos: \mbox{arreglo(arreglo(arreglo(compu)))},
      LaQMasEnvio : \mbox{nat
	}}}
}

\subsubsection*{Invariante de representación}

\begin{enumerate}
	\item Todos los IP de \textit{compus} pertenecen al conjunto de claves de \textit{CompusPorPref} y la longitud de dicho arreglo es igual al cardinal de las claves del diccionario. 
	\item Los pN de las tuplas que tiene el arreglo \textit{compus} apuntan al conjunto de paquetes(PorNom) de un significado en \textit{CompusPorPref} cuya clave es igual al IP de esa posición en el arreglo.
	\item Todos los conjuntos de los significados de \textit{CompusPorPref} son disjuntos dos a dos.
  \item Los conjuntos de los campos de la tupla PorNom, PorPrior son iguales.
  \item La longitud de \textit{CaminosMinimos} es igual a la longitud del arreglo que tiene \textit{CaminosMinimos} en cada posición.
  \item La longitud del arreglo, que tiene un arreglo de \textit{CaminosMinimos} es menor o igual a la longitud de \textit{CaminosMinimos}.
  \item Los elementos del arreglo anteriormente mencionado son menores o iguales a la longitud de \textit{CaminosMinimos} y no tiene repetidos.
  \item La computadora que más paquetes envió es aquella cuyo índice es igual a \textit{LaQMasEnvio}

\end{enumerate}
		\rep{sistema}{s} \textbf{if} $(r.izq \neq \NULL)$ \textbf{then} \\
      $1.\ \paratodo{String}{s}\ \fun{$def?$}(s, s.CompusPorPref), (\exists c : compu), \fun{$esta?$}(c,s.Compus)\ \land\ \pi_1(c) = s\ \land\ \fun{longitud}(s.Compus) = \#\Fun{claves}(s.CompusPorPref)$\\ 
      $2.\ \paratodo{compu}{c}\ \fun{esta?}(c, s.Compus), *\pi_2(c) = \fun{obtener}(\pi_1(c),s.CompusPorPref) $\\ 
      $3.\ \paratodo{String}{s,t}\ \fun{def?}(s, s.CompusPorPref)\ \land\ \fun{def?}(t, s.CompusPorPref)\ \land\ s \neq t \impluego \\ \fun{obtener}(s, s.CompusPorPref)\ \bigcap\ \fun{obtener}(t, s.CompusPorPref) = \emptyset$\\
      $4.\ \paratodo{String}{s}\ \fun{def?}(s, s.CompusPorPref)\ \impluego\ \pi_1(\fun{obtener}(s, s.CompusPorPref)) =\\ \pi_2(\fun{obtener}(s, s.CompusPorPref))$ \\
      $5.\ (\paratodo{nat}{i,j}),\ 0 \leq i,j < \fun{longitud}(s.CaminosMinimos) \impluego \fun{longitud}(s.CaminosMinimos) = \fun{longitud}(s.CaminosMinimos[i])\ \land\ \fun{longitud}(s.CaminosMinimos[i][j]) < \fun{longitud}(s.CaminosMinimos)\ \land\ (\paratodo{nat}{e}), \fun{esta?}(e, s.CaminosMinimos[i][j]) \Rightarrow e < \fun{longitud}(s.CaminosMinimos) $\\
      $8. \paratodo{compu}{c}\ \fun{esta?}(c, s.Compus)\ \impluego\ \pi_3(c) \leq \pi_3(s.Compus[s.LaQMasEnvio])$


%\subsubsection*{Función de abstracción}

 %\abs{sistema}{sist}{dcnet}{s} \\
 %$(\fun{s.} = \NULL \land \fun{*r.der} = \NULL \ssi nil?(a)) \ \oluego$ \\
% $\fun{*r.izq} = izq(a) \land \fun{*r.der} = der(a) \ \land$
%$r.val = raiz(a) $

%\rep{city}{c} \\
%	$1. \ \fun{claves}(c.\fun{robots}) \igobs \fun{claves}(c.\fun{estación}) \igobs \fun{claves}(c.\fun{tags}) \igobs \fun{claves}(c.\fun{infracciones}) \igobs \fun{claves}(c.\fun{restricciones}) \ \land $
%
%	$2. \ (\paratodo{rur}{r}) def?(r, c.robots) \yluego \\ (\exists b : tupla(nat,nat)) \ pertenece(b, obtener(obtener(r, c.estacion), c.robotsPorEstacion)) \\ \Rightarrow siguiente(obtener(r, c.robots)) = b $
%
%	$3. \ (\paratodo{estacion}{p,q}) def?(p, c.robotsPorEstacion) \land def?(q, c.robotsPorEstacion) \land p \neq q \impluego \\ Aconj(obtener(p, c.robotsPorEstacion)) \bigcap Aconj(obtener(q, c.robotsPorEstacion)) = \emptyset$
%
%	$4. \ (\paratodo{rur}{r}) \ (def?(r, c.estacion) \impluego \fun{obtener}(r,c.estacion) \in estaciones(c.mapa)) \land $
%
%$5. \ \fun{claves}(c.\fun{robotsPorEstación}) \igobs estaciones(c.mapa) \ \land $
%
%$6, 7. \ (\paratodo{estacion}{e}) \ def?(e, c.robotsPorEstacion)) \impluego  \\ (\paratodo{Tupla(infraccion,rur)}{b}) \ b \in obtener(e, c.robotsPorEstacion) \\ \impluego obtener(\pi_{2}(b), c.estacion) = e \ \land obtener(\pi_{2}(b), c.infracciones) = \pi_{1}(b) $
%
%
%$8. \ (\paratodo{rur}{r}) \ (def?(r, c.restricciones) \impluego claves(obtener(r, c.restricciones)) \igobs estaciones(c.mapa) \  \land \\   (\paratodo{estacion}{e}) \ def?(e, obtener(r, c.restricciones)) \yluego \\ (\paratodo{estacion}{c}) def?(c, obtener(e, obtener(r, c.restricciones))) \impluego \\ conectadas?(e, q, c.mapa) \yluego \\ Verifica?(obtener(r, c.tags), restriccion(c, e, c.mapa)) = obtener(c, obtener(e, obtener(r, c.restricciones)))$
%
%
%%%%%% ABS


\subsubsection*{Función de abstracción}

\abs{city}{ciudad}{e}{c}
\begin{enumerate}
\item $\fun{proximoRuR}(c) \igobs \#\fun{e.robots}\ \land$
\item $\fun{mapa}(c) \igobs e.\fun{mapa}\ \land$
\item $\fun{robots} (c)\ \igobs \fun{claves}(e.robots) \ \land$
\item $(\paratodo{rur}{r}) \ r \in robots(c) \impluego (estacion(r,c) = significado(e.estacion, r) \ \land $
\item $ tags(r,c) = significado(e.tags, r) \ \land $
\item $\# infracciones (r,c) = significado(e.infracciones, r))$
\end{enumerate}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection*{Algoritmos}

\algoritmo{icrearSistema}{in r:red}{res:dcnet}{
%inicializacion Caminos Minimos
	\State $n \larr \#(\Fun{compus}(red))$
		\complejidad{O($\#$compus(red)=n)?}
	\State $i\larr 0$
	\State $j\larr 0$
		\complejidad{O(1)}
	\State $res.Compus \larr \Fun{CrearArreglo}(n)$
		\complejidad{O(n)}
	\State $res.CaminosMinimos\larr \Fun{CrearArreglo}(n)$
		\complejidad{O(n)}
	\Var{p: arreglo$\_$dimensionable de puntero(conjLog(paquete))}	
	\While{i$<$n}
		\complejidad{O(n)}
		\State $res.CaminosMinimos[i] \larr \Fun{CrearArreglo}(n)$ 
			\complejidad{O(n)}
		\State $p[i] \larr NULL$
			\complejidad{O(1)}
		\State $res.Compus[i] \larr $ \textbf{tupla}$<compu(r,i),p[i],0,0>$ 
		\State no se como se deben escribir las tuplas
			\complejidad{O(1)}
		\State \Fun{definir}(res.CompusPorPref,compu(r,i))
			\complejidad{O(L)}
		\While{j$<$n}
			\complejidad{O(n)}
			\State $res.CaminosMinimos[i][j] \larr caminoMinimo(compu(r,i),compu(r,j),r)$
				\complejidad{O(complejidad cammin(red))}
			\State $j++$
		\EndWhile
		\State $i++$	
	\EndWhile
	\State $res.LaQMasEnvio \larr 0$
		\complejidad{O(1)}
%holi
}
{O(max\{$n^2 \times O(complejidad cammin(red)),n \times L\}$)}

\algoritmo{icrearPaquete}{in/out s:dcnet,in p: paquete}{}{ %hay que cambiar nombres segun heap y avl
  \State $t: \ < conjLog(paquete),\ conjLog(paquete) >$
  \State $t \larr \Fun{Obtener}(\pi_3(p),\ \var{s}.CompusPorPref)$
        \complejidad{O($L$)}
  \Fun{insertar}($\pi_1(t),p$) %agrega segun nombre
        \complejidad{O($log(k)$)}
  \Fun{insertar}($\pi_2(t),p$) %agrega segun prioridad
        \complejidad{O($log(k)$)}
}
{O($L + log(k)$)}


\algoritmo{ilaQueMasEnvio}{in s: dcnet}{res : compu}{
  \State $res \larr \pi_1(s.compus[s.LaQMasEnvio])$ 
        \complejidad{O(1)}
}
{O(1)}

\algoritmo{ienEspera}{in s:dcnet,in c: compu}{res: puntero(conjLogP(paquete))}{
  \State $t: \ < conjLog(paquete),\ conjLog(paquete) >$
  \State $t \larr \Fun{Obtener}(\pi_1(c),\ \var{s}.CompusPorPref)$
        \complejidad{O($L$)}
  \State $res \larr \&(\pi_2(t))$
        \complejidad{O(1)}
}
{O($L$)}

\algoritmo{iavanzarSegundo}{in/out s:dcnet}{}{ %FALTA ARREGLAR EL INDICE DE LA QUE MAS ENVIO
  \Var{i: nat} % NO ME COMPILA ESTOOOOO
  \State $i \larr 0$
        \complejidad{O(1)}
  \Var{m: nat}
  \State $m \larr s.LaQMasEnvio$
  \While{$i < \Fun{Longitud}(s.compus)$} %aca supongo que el modulo arreglo tiene la operacion longitud 
        \complejidad{O(n)} 
  \If{$\neg\Fun{vacia?}$}
    \Var{IP: String}
    \State $IP \larr \pi_1(s.compu[i])$
    \State $t_1: \ < conjLog(paquete),\ conjLog(paquete) >$
    \State $t_1 \larr \Fun{obtener(IP, s.CompusPorPref)}$
          \complejidad{O(L)}
    \Var{p: paquete}
    \State $p \larr \Fun{sacarMax}(\pi_2(t_1))$ %tengo en p el paquete que voy a mover
          \complejidad{O($log(k)$)}
    $\Fun{borrar}(\pi_2(t_1),\ p)$ %lo borro del avl por prioridad
          \complejidad{O($log(k)$)}
    $\Fun{borrar}(\pi_1(t_1),\ p)$ %lo borro del avl por nombre
          \complejidad{O($log(k)$)}
    $\pi_3(s.compus[i]) \larr \pi_3(s.compus[i]) + 1$
           \complejidad{O(1)}
    \State $t_2: \ < conjLog(paquete),\ conjLog(paquete) >$
    \State $t_2 \larr \Fun{obtener}(\pi_4(P), s.CompusPorPref)$
             \complejidad{O(L)}
    $\Fun{insertar}(\pi_2(t_2),\ p)$ \\
          \complejidad{O($log(k)$)}
    $\Fun{insertar}(\pi_1(t_2),\ p)$
          \complejidad{O($log(k)$)}
    \If{$\pi_3(s.compus[i] > max)$}
          \complejidad{O(1)}
      \State $ max \larr i$
           \complejidad{O(1)}
    \EndIf
  \EndIf
  \State$i \larr i + 1$
  \EndWhile
  \State$ s.LaQMasEnvio \larr max$ 
      \complejidad{O(1)}
}
{O($ n \times(L + log(k)$))}

\algoritmo{icantidadEnviados}{in/out s:dcnet,in c: compu}{res : nat}{ 
  \Var{i: nat} 
  \State $i \larr 0$
        \complejidad{O(1)}
  \While{$\pi_1(s.compus[i]) \neq \pi_1(c)$} %este ciclo termina antes de superar la long del array por la pre
        \complejidad{O(n)} 
    \State$i \larr i + 1$
          \complejidad{O(1)}
  \EndWhile
  \State$res \larr \pi_3(s.compus[i])$
        \complejidad{O(1)}
}
{O(n)}

\algoritmo{icaminoRecorrido}{in s:dcnet,in p: paquete}{res : secu(compu)}{ 
  \Var{i: nat} 
  \State $i \larr 0$
        \complejidad{O(1)}
  \Var{b: bool}
  \State $b \larr \neg(\Fun{pertenece?}(p,\pi_3(s.compus[i])))$
        \complejidad{O($log(k)$)}
  \While{$b$}
        \complejidad{O(n)} 
    \State$i \larr i + 1$
          \complejidad{O(1)}
    \State $b \larr \neg(\Fun{pertenece?}(p,\pi_3(s.compus[i])))$
          \complejidad{O($log(k)$)}
  \EndWhile
  \Var{j: nat}
  \State $j \larr 0$
        \complejidad{O(1)}
  \While{$\pi_1(s.compus[j]) \neq \pi_3(p)$}
        \complejidad{O(n)} 
    \State$i \larr j + 1$
          \complejidad{O(1)}
  \EndWhile
  \State$res \larr s.CaminosMinimos[j][i]$
        \complejidad{O(1 o n dependiendo de si hago copia o no)}
}
{O($n \times log(k)$)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Servicios Usados}


