%!TEX root = tp2.tex

% (\paratodo{String}{c}) \ esta?(c,secuSubY(s)) \Rightarrow verifica?(c,r)$}

Una DCNet es

\subsection{Interfaz}

\sexc{DCNet}
\generos{dcnet}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection*{Operaciones}


\operacion{crearSistema}{in r: red}{res : dcnet}
 {true}
 {$completar$}
 {Crea un sistema DCNet.}
 {O(?????)}

\operacion{dameRed}{in s: dcnet}{res : red}
 {$true$}
 {$\var{res} \igobs red(s)$}
 {Devuelve la red de DCNet.}
 {O($?????$)}

\operacion{caminoRecorrido}{in s: dcnet, in p: paquete}{res : secu(compu)}
 {$paqueteEnTransito?(s,p)$}
 {$\var{res} \igobs caminoRecorrido(s,p)$}
 {Devuelve el camino recorrido hasta el momento por un paquete.}
 {O($n \times\  log(max(n,k))$)}

\operacion{laQueMasEnvio}{in s: dcnet}{res : compu}
 {$true$}
 {$\var{res} \igobs laQueMasEnvio(s,p)$}
 {Devuelve la computadora que más paquetes envió.}
 {O(1)}

\operacion{crearPaquete}{in/out s: dcnet, p: paquete}{}
 {$s \igobs s_0 \land FALTA CHOCLO$}
 {$enEspera(s,\pi_3(p)) \igobs enEspera(s_0,\pi_3(p) \cup \{p\}$}
 {$Crea un paquete y lo agrega a la computadora correspondiente.$}
 {O($L + log(k)$)}

\operacion{enEspera}{in s: dcnet, c: compu}{res: ItColaLogP(paquete)}
 {$c \in computadoras(red(s))$}
 {$\var{res} \igobs enEspera(s,c) DUDOSO?????????????????$}
 {Devuelve un iterador a los paquetes de la computadora.}
 {O(L)}

\operacion{avanzarSegundo}{in/out s: dcnet}{}
 {$s \igobs s_0$}
 {$completar$}
 {Avanza un segundo el sistema. Todas las computadoras envían su respectivo paquete y en consecuencia se actualizar los paquetes en espera de cada una de ellas.}
 {O($n \times\ (L + log(n) + log(k))$)}

\operacion{cantidadEnviados}{in s: dcnet, in c: compu}{res : nat}
 {$c \in computadoras(red(s))$}
 {$\var{res} \igobs cantidadEnviados(s,c)$}
 {Devuelve la cantidad de paquetes enviados por una computadora.}
 {O(ESTO FALTA AGREGARLO A LA ESTRUCTURA NO ???)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\subsection{Representación}

%\serc{sistema}{
%	\\
%	\donde{sistema}{\tupla{
%			Compus : \mbox{arreglo(\tupla{IP: String , pP: itColaLogP, pN: itColaLog})}, %esto quedo feo
%			PaquetesPorPrioridad : \mbox{diccPref(compu, colaLogP(paquete))},
%			PaquetesPorID : \mbox{diccPref(compu, colaLog(paquete))},
%			CompusPor\#Envios : \mbox{colaLogP(compus)}
%	}}
%}


%\subsubsection*{Invariante de representación}

%\begin{enumerate}
%	\item si son hojas son tags
%	\item sino, son operadores
%	\item si el operador es unario, tiene solo hijo izquierdo

%		\rep{restr}{r} \textbf{if} $(r.izq \neq \NULL)$ \textbf{then} \\
%		\textbf{if} ($r.der = \NULL$) \textbf{then} \\
%		$*r.val = "NOT" \land rep(*r.izq)$ \\
%		\textbf{else} $*r.val \in Ag("OR", Ag("AND",vacio)) \land rep(*r.izq) \land rep(*r.der)$
%		\end{enumerate}

%\subsubsection*{Función de abstracción}

 %\abs{sistema}{sist}{dcnet}{s} \\
 %$(\fun{s.} = \NULL \land \fun{*r.der} = \NULL \ssi nil?(a)) \ \oluego$ \\
% $\fun{*r.izq} = izq(a) \land \fun{*r.der} = der(a) \ \land$
%$r.val = raiz(a) $

%\subsubsection*{Algoritmos}



