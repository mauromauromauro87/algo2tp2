%!TEX root = tp2.tex
\section{Red}
El módulo red permite crear una red de computadoras, agregar nuevas, conectarlas y averiguar el camino mínimo entre dos de ellas.


\subsection{Interfaz}

\sexc{Red}
\generos{red}

\subsubsection*{Operaciones}

\operacion{Nueva}{}{res : red}
 {true}
 {$\var{res} \equiv$ iniciarRed}
 {Crea una red vacía}
 {O(1)}

\operacion{InterfazUsada}{in r:red, in c:compu, in c1:compu}{res:interfaz}
{$\neg(c = c1) \land c \in compus(r) \land c1 \in compus(r)$}
{$res \igobs InterfazUsada(r,c,c1)$}
{Retorna por copia la interfaz de la primer compu recibida por parámetro usada para conectarse con la segunda}
{O($\#$(compus(r)))}

\operacion{Compus}{in r:red}{res:conj(compu)}
{$true$}
{$res \igobs computadoras(r)$}
{Devuelve el conjunto de compus}
{O(1)}
{Retorna el conjunto de computadoras por referencia}

\operacion{Conectadas?}{in r:red, in c:compu, in c1:compu}{res:bool}
{$\neg(c = c1) \land c \in compus(r) \land c1 \in compus(r)$}
{$res \igobs conectadas?(r)$}
{Indica si dos compus estan conectadas}
{O($\#$compus(r))}
{}

\operacion{AgregarCompu}{in/out r : red,in c : compu}{}
 {$r \equiv r_0$ $\land$ ($\forall$ $\var{$c_{1}$}$:compu)($\var{$c_{1}$}$ $\in$ computadoras($\var{r}$))$\implies$ IP($\var{c}$) $\neq$ IP($\var{$c_{1}$}$)}
 {$\var{r} \equiv$ agregarComputadora($\var{r},\var{c}$)}
 {Agrega a la red $\var r$ la computadora $\var c$}
 {O(n + copy(c))}

\operacion{Conectar}{in/out r : red,in c1 : compu,in i1 : interfaz,in c2 : compu,in i2 : interfaz}{}
 {$r \equiv r_0$ $\land$ $\var{$c_{1}$}$ $\in$ computadoras($\var{r}$) $\land$ $\var{$c_{2}$}$ $\in$ computadoras($\var{r}$) $\land$ IP(c1) $\neq$ IP(c2) \\ $\land$ $\neg$conectadas(r,c1,c2) $\land$ $\neg$UsaInterfaz?(r,c1,i1) $\land$ $\neg$UsaInterfaz?(r,c2,i2)}
 {$\var{r} \equiv$ conectar($\var{r},\var{c1},\var{i1},\var{c2},\var{i2}$)}
 {Conecta las computadoras $\var{$c_{1}$}$ y $\var{$c_{2}$}$}
 {O(n)}

\operacion{CaminoMinimo}{in r : red, in f : compu, in d : compu}{res : secu(compu)}
 {$\var{$c_{1}$}$ $\in$ computadoras($\var{r}$) $\land$ $\var{$c_{2}$}$ $\in$ computadoras($\var{r}$)}
 {$\var{r} \equiv$ caminosMinimos($\var{r}$,$\var{$c_{1}$}$,$\var{$c_{2}$}$)}
 {Devuelve los caminos mínimos entre dos computadoras}
 {O($????????????????????????????$)}

\operacion{StringAIndice}{in r : red,in c : compu}{res : nat}
 {$\var{c}$ $\in$ computadoras($\var{r}$)}
 {$\var{res}$ $\equiv$ indice($\var{r}$,$\var{c}$)}
 {Devuelve un nat distinto para cada IP}
 {O(n)}

\operacion{UsaInterfaz?}{in r : red,in c : compu,in i : interfaz}{res : bool}
 {$\var{c}$ $\in$ computadoras($\var{r}$) $\land$ $\var{i}$ $\in$ interfaces($\var{c}$)}
 {$\var{res} \equiv UsaInterfaz?(r,c,i)$}
 {Devuelve TRUE si y solo si la interfaz está siendo utilizada}
 {O(n)}

\operacion{HayCamino?}{in r : red,in c1 : compu,in c2 : compu}{res : bool}
 {$\var{$c_{1}$}$ $\in$ computadoras($\var{r}$) $\land$ $\var{$c_{2}$}$ $\in$ computadoras($\var{r}$)}
 {$\var{res} \equiv HayCamino?(r,c1,c2)$}
 {Devuelve TRUE sí y solo sí hay un camino válido entre las dos computadoras}
 {O($???????????????????????????$)}

\subsection{Representación}
\serc{redstr}{
		\donde{redstr}{\tupla{
				Compus : \mbox{conj(compu)},
				Conexiones : \mbox{dicc(compu,dicc(interfaz,compu))}
		}}
		\donde{compu}{\tupla{
			IP : \mbox{string},
			interfaces : \mbox{conj(interfaz)}
		}}
		\donde{interfaz}{nat}
}

\subsection{Invariante de representación}
\begin{enumerate}
\item El conjunto de claves de conexiones está incluído o es igual al conjunto de compus
\item 'Simetría en las conexiones' : Cada una de las claves de conexiones está en los significados de las compus a las que está conectada
\item Las compus conectadas a c están en las claves de las conexiones
\item Las claves del significado de cada una de las compus 'c' está incluída en el conjunto de interfaces de 'c'
\end{enumerate}

\subsubsection*{Rep.}
\begin{enumerate}
\item[] $claves(conexiones(r)) \subseteq compus(r)$ $\land$
\item[] $((\forall c : compu)$ $c \in claves(conexiones(r))) \impluego \\
		((\forall c_1 : compu) c_1 \in conectadas(conexiones(r),c))$ $\impluego$ $c_1 \in claves$ $\yluego$ $c \in conectadas(conexiones(r),c_1)$
\end{enumerate}

\subsection{Función de abstracción}

\abs{redstr}{red}{rstr}{r} \\
$computadoras(r) \igobs rstr.compus$ $\land$ \\
$(\forall c_0,c_1:compu)$ $conectadas?(r,c_0,c_1)$ $\igobs$ $c_1 \in conectadas(rstr.conexiones,c_0)$ $\land$\\
$interfazUsada(r,c_0,c_1)$ $\igobs$ $dameClave(significado(rstr.conexiones,c_0),c_1)$

\subsubsection*{Extensión TAD diccionario}
\begin{description} 
\item[] $conectadas:$ $dicc(compu,dicc(interfaz,compu))$ $d$ $\times$ $compu$ $c$ $\rarr$ $conj(compu)$ \setlength{\parindent}{1cm} \indent
\item[] $conectadas(d)$ $=$  $obtenerSignificados(significado(d,c),claves(significado(d,c)))$
\\
\item[] $obtenerSignificados:$ $dicc(interfaz,compu)$ $d$ $\times$ $conj(interfaz)$ $ci$ $\rarr$ $conj(compu)$ \setlength{\parindent}{0.1cm} \indent
\item[] $obtenerSignificados(d,c)$ $=$
	\setlength{\parindent}{1cm}\\ \textbf{if} $(\#(c) = 0)$ \textbf{then}
		\\ \indent$\emptyset$
	\\ \textbf{else} 
		\\\indent  $significado(d,dameUno(c))$ $\cup$ $obtenerSignificado(d,sinUno(c))$
	\\  \textbf{fi} 
\end{description}

\subsection{Algoritmos}
\algoritmo{iNueva}{}{res:redstr}
{
\State $res$ $\larr$ $CrearTupla(compus:conj(compu),conexiones:dicc(compu,dicc(interfaz,compu)))$ \complejidad{O(1)}
\State $res.conexiones$ $\larr$ $Vacio()$  \complejidad{O(1)}
\State $res.compus$ $\larr$ $Vacio()$ \complejidad{O(1)}
\State $return$ $res$
}
{O(1)}

\algoritmo{iAgregarCompu}{in/out r:redstr, in c:compu} {}{
	\State $AgregarRapido(r.compus,c)$ \complejidad{O(1)}
}
{O(1)}

\algoritmo{iConectar}{in/out r:redstr, in c$_0$:compu, in c$_1$:compu, in i$_0$:interfaz, in i$_1$:interfaz}{}{
	\If {$\neg$ $(definido?(r.conexiones,c_0))$}
		\State $definir(r.conexiones,c_0,Vacio())$ \complejidad{O($\# (r.compus)$)}
	\EndIf
	\If {$\neg$ $(definido?(r.conexiones,c_1))$}
		\State $definir(r.conexiones,c_1,Vacio())$ \complejidad{O($\# (r.compus)$)}
	\EndIf
	\State $definir(significado(r.conexiones,c_0),i_0,c_1)$ \complejidad{O($\# (r.compus)$)}
	\State $definir(significado(r.conexiones,c_1),i_1,c_0)$ \complejidad{O($\# (r.compus)$)}
}
{O($\#$ $(r.compus)$)}

\algoritmo{iStringAIndice}{in r:redstr, in c:compu}{res:nat}{
	\State $itCompus$ $\larr$ $CrearIt(r.compus)$ \complejidad{O(1)}
	\\
	\State $//$ $L = longitud de IP mas larga$
	\While {$itCompus.siguiente().IP != c.IP$} \complejidad{O(L)}
		\State $res ++$ \complejidad{O(1)}
		\State $avanzar(itCompus)$ \complejidad{O(1)}
	\EndWhile
	\State $return$ $res$ \complejidad{O(1)}
}
{O($\#(r.compus)*L$)}

\algoritmo{iUsaInterfaz}{in r:redstr, in c:compu, in i:interfaz}{res:bool}{
	\State \If {$definido?(r.conexiones,c)$} \complejidad{O($\#(r.compus)$)}
		\State res $\larr$ $definido?(significado(r.conexiones,c),i)$ \complejidad{O($\#(r.compus)$)}
	\Else
		\State res $\larr$ $false$ \complejidad{O($1$)}
	\EndIf
	\State $return$ $res$ \complejidad{O($1$)}
}
{O($\#(r.compus)$)}

\algoritmo{iConectadas?}{in r:redstr, in c$_1$:compu, in c$_2$:compu}{res:bool}{
	\State $res$ $\larr$ $pertence(c_2,significados(significado(r.conexiones,c_1)))$ \complejidad{O($\#(r.compus)$)}
	\State $return$ $res$ \complejidad{O(1)}
}
{O($\#(r.compus)$)}

\algoritmo{iInterfazUsada}{in r:redstr, in c$_1$:compu, in c$_2$:compu}{res:interfaz}{
	\State $res$ $\larr$ $dameClave(significado(d,c_1),c_2)$ \complejidad{O($\#(r.compus)$)}
	\State $return$ $res$ \complejidad{O(1)}
}
{O($\#(r.compus)$)}

\algoritmo{iCaminoMinimo}{in r:red, in f:compu, in d:compu}{res : bool}{
	\State \Var{auxCaminos:$Lista(Lista(compu))$} $\larr Vacia()$ \complejidad{O(1)}
	\State \Var{visitados:$Lista(compu)$} $\larr Vacia()$ \complejidad{O(1)}
	\State AgregarAdelante(auxCaminos, Lista(f)) \complejidad{O(1)}
	\State AgregarAdelante(visitados, f) \complejidad{O(1)}
	\State \While {$(Longitud(auxCaminos) != 0)$} \complejidad{O(1)}
		\State \Var{camino:$Lista(compu)$} $\larr sacarMenor(auxCaminos)$ \complejidad{O($??????????????$)}
		\State \If {$Ultimo(camino) == d$} \complejidad{$O(1)$}
			\State $res \larr camino$ \complejidad{$O(1)$}
			\State $return$ $res$ \complejidad{O(1)}
		\EndIf
		\State \Var{vecinos:$Lista(compu)$} $\larr nuevosVecinos(camino,visitados)$ \complejidad{O($?????????????????$)}
		\State \While {$Longitud(vecinos) != 0$} \complejidad{O(1)}
			\State \Var{caminoAux:$Lista(compu)$} $\larr camino$ \complejidad{$O(1)$}
			\State $AgregarPrimero(caminoAux,vecinos[0])$ \complejidad{$O(1)$}
			\State $Eliminar(vecinos,vecinos[0])$ \complejidad{$O(n)$}
			\State $AgregarPrimero(auxCaminos, caminoAuxiliar)$ \complejidad{$O(??????????????????)$}
		\EndWhile
		\State $AgregarAVisitados(visitados, auxCaminos)$ \complejidad{$O(???????????????????????)$}
	\EndWhile
	\State $res \larr Vacia(Vacia())$ \complejidad{O(1)}
}{O($????????????????????????$)}

\algoritmo{iNuevosVecinos}{in r:redstr, in camino:$Lista(compu)$, in visitados:$Lista(compu)$}{res : $Lista(compu)$}{
	\State \Var{long:$nat$} $\larr$ $Longitud(camino)$ \complejidad{O(1)}
	\State \Var{vecinos:$Lista$} $\larr$ $significados(significado(r.conexiones,camino[long-1]))$ \complejidad{O($\#(r.compus)$)}
	\State \Var{itVecinos:$itDicc$}$(interfaz,compu)$ $\larr$ $CrearIterador(vecinos)$ \complejidad{O(1)}
	\State \Var{haySiguiente:$bool$} $\larr$ $(longitud(vecinos) != 0)$ \complejidad{O(1)}
	\While {$haySiguiente$} \complejidad{O($1$)}
		\State \Var{vecino:$compu$} $\larr$ $actual(itVecinos)$ \complejidad{O(1)}
		\If {$\neg(Esta(visitados,vecino))$} \complejidad{O($\#(r.compus)$)}
			\State $AgregarUltimo(vecinos,vecino)$ \complejidad{O(1)}
		\EndIf
		\State $avanzar(itVecinos)$ \complejidad{O(1)}
		\State $haySiguiente$ $\larr$ $haySiguiente(itVecinos)$ \complejidad{O(1)}
	\EndWhile
	\State $res$ $\larr$ $vecinos$ \complejidad{O(1)}
}
{O($\#(r.compus)^2$)}

\algoritmo{iSacarMenor}{in/out caminos:$Lista(Lista(compu)$}{res:$Lista(compu)$}{
	\State \Var{size:$nat$} $\larr Longitud(caminos)$ \complejidad{O(1)}
	\State \Var{i:$nat$} $\larr 0$ \complejidad{O(1)}
 	\State \While {$i < size$} \complejidad{O(1)}
		\State \If{$Longitud(caminos[i]) == minimo(caminos)$} \complejidad{O($???????????$)}
			\State $Eliminar(caminos,caminos[i])$ \complejidad{O($???????????$)}
			\State $res \larr caminos[i]$ \complejidad{O(1)}
		\EndIf
		\State $i++$
	\EndWhile
}
{O(?????????????????????)}

\algoritmo{iAgregarVisitados}{in/out visitados:$Lista(compu)$, in caminos:$Lista(Lista(compu))$}{}{
	\State \Var{size:$nat$} $\larr Longitud(caminos)$ \complejidad{O(1)}
	\State \Var{i:$nat$} $\larr 0$ \complejidad{O(1)}
 	\State \While {$i < size$} \complejidad{O(1)}
		\State $AgregarUltimo(visitados, Ultimo(caminos[i]))$ \complejidad{O(1)}
		\State $i++$ \complejidad{O(1)}
	\EndWhile
}
{O(????????????????)}
